#!/usr/bin/env python
#coding: utf-8

__author__ = 'Toshihiro Kamiya <kamiya@mbj.nifty.com>'
__status__ = 'experimental'

import sys

from enum_generator import EnumGenerator
import clonefile_manip as cm

def is_shallower_than(depthseq1, depthseq2):
    return depthseq1 != depthseq2 and max(d1 - d2 for d1, d2 in zip(depthseq1, depthseq2)) <= 0

def remove_deeper_clones(read_clone_iter, ope_enum, startingloc_enum, 
        options_section_handler=None):
    startloc2depth_opeseq = {}  # startloc_iseq -> [(depth_seq, ope_iseq)]
    for tag, data in read_clone_iter:
        if tag == cm.OPTIONS:
            if options_section_handler:
                options_section_handler(data)
        elif tag == cm.OPESEQ_LOCS:
            opeseq, locseq = data
            ope_iseq = tuple(map(ope_enum.to_int, opeseq))
            startloc_seq = []
            depth_seq = []
            for loc in locseq:
                s, d = loc.split('>')
                startloc_seq.append(s.strip())
                depth_seq.append(int(d))
            startloc_iseq = tuple(map(startingloc_enum.to_int, startloc_seq))
            depth_seq = tuple(depth_seq)
            v = startloc2depth_opeseq.get(startloc_iseq)
            if v:
                for d, o in v:
                    if is_shallower_than(d, depth_seq):
                        # found some clone deeper than the current
                        break  # for d, o
                else:
                    # no clone is deeper than the current
                    w = [d_o for d_o in v if not is_shallower_than(depth_seq, d_o[0])] # remove clones which shallower than the current
                    v[:] = w
                    v.append((depth_seq, ope_iseq))
            else:
                startloc2depth_opeseq[startloc_iseq] = [(depth_seq, ope_iseq)]
        else:
            sys.exit('invalid line. not a clone-index file?')
            assert False
    
    ope_startloc_depth_list = sorted((ope_iseq, startloc_iseq, depth_seq) \
            for startloc_iseq, lst in startloc2depth_opeseq.iteritems() \
            for depth_seq, ope_iseq in lst)
    return ope_startloc_depth_list

def gen_argpsr():
    from argparse import ArgumentParser
    from _version_data import VERSION
    psr = ArgumentParser(description='Merge multiple-depth clones. merge the clones having distinct depths but having the same starting position.')
    psr.add_argument('clone_index', action='store',
            help="clone-index file (generated by det-clone.py). specify '-' to read from stdin")
    psr.add_argument('--version', action='version', version='%(prog)s ' + VERSION)
    return psr

def main(argv):
    psr = gen_argpsr()
    args = psr.parse_args(argv[1:])

    clone_index_file = args.clone_index

    ope_enum = EnumGenerator()
    startingloc_enum = EnumGenerator()

    def print_options(data):
        sys.stdout.write('\n'.join(data.format() + ['']))
        sys.stdout.write('\n')

    it = cm.read_clone_file_iter(clone_index_file)
    ope_startloc_depth_list = remove_deeper_clones(it, ope_enum, startingloc_enum,
            options_section_handler=print_options)

    for ope_iseq, startloc_iseq, depth_seq in ope_startloc_depth_list:
        sys.stdout.write('ope:\n')
        for opei in ope_iseq:
            ope = ope_enum.to_str(opei)
            sys.stdout.write('  %s\n' % ope)
        
        sys.stdout.write('loc:\n')
        for (startingloci, depth) in zip(startloc_iseq, depth_seq):
            startingloc = startingloc_enum.to_str(startingloci)
            sys.stdout.write('  %s >%d\n' % (startingloc, depth))

        sys.stdout.write('\n')

if __name__ == '__main__':
    main(sys.argv)


